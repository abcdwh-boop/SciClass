<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>기체 입자 시뮬레이션</title>
    <!-- Tailwind CSS 로드 --><script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Inter 폰트 적용 */
        body {
            font-family: 'Inter', sans-serif;
        }
        /* 캔버스 기본 배경색 (JS에서도 덮어쓸 수 있음) */
        canvas {
            background-color: #f8f9fa;
        }
    </style>
</head>
<body class="bg-gray-100 flex flex-col items-center justify-center min-h-screen p-4">

    <h1 class="text-2xl font-bold mb-4">기체 입자 시뮬레이션</h1>

    <canvas id="simulationCanvas" width="500" height="500" class="border-2 border-black rounded-lg shadow-lg"></canvas>

    <!-- 버튼 컨테이너 -->
    <div class="flex space-x-4 mt-4">
        <!-- 입자 추가 버튼 -->
        <button id="addButton" class="px-6 py-3 bg-blue-600 text-white font-semibold rounded-lg shadow-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-75 transition duration-200 ease-in-out">
            입자추가 (0)
        </button>
        <!-- 온도 조절 버튼 (Up) -->
        <button id="tempUpButton" class="px-6 py-3 bg-green-600 text-white font-semibold rounded-lg shadow-md hover:bg-green-700 focus:outline-none focus:ring-2 focus:ring-green-500 focus:ring-opacity-75 transition duration-200 ease-in-out">
            온도 Up
        </button>
        <!-- 온도 조절 버튼 (Down) -->
        <button id="tempDownButton" class="px-6 py-3 bg-red-600 text-white font-semibold rounded-lg shadow-md hover:bg-red-700 focus:outline-none focus:ring-2 focus:ring-red-500 focus:ring-opacity-75 transition duration-200 ease-in-out">
            온도 Dn
        </button>
    </div>

    <script>
        const canvas = document.getElementById('simulationCanvas');
        const ctx = canvas.getContext('2d');
        const addButton = document.getElementById('addButton');
        // const tempButton = document.getElementById('tempButton'); // 기존 버튼 제거
        const tempUpButton = document.getElementById('tempUpButton'); // Up 버튼
        const tempDownButton = document.getElementById('tempDownButton'); // Down 버튼

        // 상자 크기 (캔버스 크기와 동일)
        const box = {
            width: canvas.width,
            height: canvas.height
        };

        let particles = [];
        let particleCount = 0;
        let temperature = 0;
        const baseSpeed = 4;
        const WALL_THICKNESS = 15; // 벽 두께 3배 증가 (기존 border-2에서 2px 였으므로 6px * 2 = 12px, canvas border도 있어 총 15px)

        // 벽 섹션 배열 초기화
        const numWallSegments = 10;
        const wallSegments = {
            top: Array(numWallSegments).fill(0),
            bottom: Array(numWallSegments).fill(0),
            left: Array(numWallSegments).fill(0),
            right: Array(numWallSegments).fill(0)
        };

        // 1초마다 충돌 횟수를 초기화하는 타이머
        setInterval(() => {
            for (const wall in wallSegments) {
                wallSegments[wall].fill(0);
            }
        }, 1000); // 1000ms = 1초

        // 온도를 기반으로 속도 배율 계산
        function calculateSpeedMultiplier() {
            return baseSpeed + (temperature * 0.2); 
        }

        // 충돌 횟수에 따른 색상 매핑 함수
        function getWallColor(hits) {
            if (hits >= 5) return 'red';
            if (hits === 4) return 'orange';
            if (hits === 3) return 'deeppink'; // 분홍색
            if (hits === 2) return 'lime';     // 초록색 (더 밝은 초록색)
            if (hits === 1) return 'dodgerblue'; // 파란색 (더 밝은 파란색)
            return '#ccc'; // 기본 회색 (충돌 0회)
        }

        class Particle {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.radius = 3;
                this.color = `hsl(${Math.random() * 360}, 70%, 50%)`;
                
                const speedMultiplier = calculateSpeedMultiplier();
                this.vx = (Math.random() - 0.5) * speedMultiplier; 
                this.vy = (Math.random() - 0.5) * speedMultiplier;
            }

            draw() {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = this.color;
                ctx.fill();
                ctx.closePath();
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;

                // 벽 충돌 감지 및 반사
                // 왼쪽 또는 오른쪽 벽
                if (this.x - this.radius < WALL_THICKNESS || this.x + this.radius > box.width - WALL_THICKNESS) {
                    this.vx *= -1;
                    // 벽을 벗어나지 않도록 위치 보정
                    if (this.x - this.radius < WALL_THICKNESS) this.x = this.radius + WALL_THICKNESS;
                    if (this.x + this.radius > box.width - WALL_THICKNESS) this.x = box.width - this.radius - WALL_THICKNESS;

                    // 충돌 횟수 증가
                    const segmentSize = (box.height - 2 * WALL_THICKNESS) / numWallSegments;
                    const segmentIndex = Math.floor((this.y - WALL_THICKNESS) / segmentSize);
                    if (this.x < box.width / 2) { // 왼쪽 벽
                        if (segmentIndex >= 0 && segmentIndex < numWallSegments) {
                            wallSegments.left[segmentIndex]++;
                        }
                    } else { // 오른쪽 벽
                        if (segmentIndex >= 0 && segmentIndex < numWallSegments) {
                            wallSegments.right[segmentIndex]++;
                        }
                    }
                }
                
                // 위쪽 또는 아래쪽 벽
                if (this.y - this.radius < WALL_THICKNESS || this.y + this.radius > box.height - WALL_THICKNESS) {
                    this.vy *= -1;
                    // 벽을 벗어나지 않도록 위치 보정
                    if (this.y - this.radius < WALL_THICKNESS) this.y = this.radius + WALL_THICKNESS;
                    if (this.y + this.radius > box.height - WALL_THICKNESS) this.y = box.height - this.radius - WALL_THICKNESS;

                    // 충돌 횟수 증가
                    const segmentSize = (box.width - 2 * WALL_THICKNESS) / numWallSegments;
                    const segmentIndex = Math.floor((this.x - WALL_THICKNESS) / segmentSize);
                    if (this.y < box.height / 2) { // 위쪽 벽
                        if (segmentIndex >= 0 && segmentIndex < numWallSegments) {
                            wallSegments.top[segmentIndex]++;
                        }
                    } else { // 아래쪽 벽
                        if (segmentIndex >= 0 && segmentIndex < numWallSegments) {
                            wallSegments.bottom[segmentIndex]++;
                        }
                    }
                }
            }
        }

        // 호스 및 펌프 그리기 (정적) - 벽 섹션 그리기 포함
        function drawStaticElements() {
            // 벽 섹션 그리기
            const segmentWidth = (box.width - 2 * WALL_THICKNESS) / numWallSegments;
            const segmentHeight = (box.height - 2 * WALL_THICKNESS) / numWallSegments;

            // 상단 벽
            for (let i = 0; i < numWallSegments; i++) {
                ctx.fillStyle = getWallColor(wallSegments.top[i]);
                ctx.fillRect(WALL_THICKNESS + i * segmentWidth, 0, segmentWidth, WALL_THICKNESS);
            }
            // 하단 벽
            for (let i = 0; i < numWallSegments; i++) {
                ctx.fillStyle = getWallColor(wallSegments.bottom[i]);
                ctx.fillRect(WALL_THICKNESS + i * segmentWidth, box.height - WALL_THICKNESS, segmentWidth, WALL_THICKNESS);
            }
            // 좌측 벽
            for (let i = 0; i < numWallSegments; i++) {
                ctx.fillStyle = getWallColor(wallSegments.left[i]);
                ctx.fillRect(0, WALL_THICKNESS + i * segmentHeight, WALL_THICKNESS, segmentHeight);
            }
            // 우측 벽
            for (let i = 0; i < numWallSegments; i++) {
                ctx.fillStyle = getWallColor(wallSegments.right[i]);
                ctx.fillRect(box.width - WALL_THICKNESS, WALL_THICKNESS + i * segmentHeight, WALL_THICKNESS, segmentHeight);
            }

            // 펌프 (회색 사각형) - 벽 두께 고려 위치 조정
            ctx.fillStyle = '#888';
            ctx.fillRect(box.width - WALL_THICKNESS, box.height - WALL_THICKNESS, WALL_THICKNESS, WALL_THICKNESS); 

            // 호스 (진회색 선) - 벽 두께 고려 위치 조정
            ctx.strokeStyle = '#555';
            ctx.lineWidth = 8;
            ctx.beginPath();
            ctx.moveTo(box.width - WALL_THICKNESS / 2, box.height - WALL_THICKNESS / 2); // 펌프 중앙
            ctx.lineTo(box.width - WALL_THICKNESS - 10, box.height - WALL_THICKNESS - 10); // 상자 안쪽을 향함
            ctx.stroke();

            // 온도 표시 (새로 추가)
            ctx.fillStyle = 'black';
            ctx.font = '16px Inter, sans-serif'; // 버튼 글꼴 크기와 유사하게 설정
            ctx.textAlign = 'right'; // 우측 정렬
            ctx.textBaseline = 'top'; // 상단 기준
            // 캔버스 우측 상단 (벽 안쪽)에 텍스트 그리기
            ctx.fillText(`${temperature}도`, box.width - WALL_THICKNESS - 10, WALL_THICKNESS + 10);
        }

        function addParticles() {
            for (let i = 0; i < 50; i++) {
                // 호스 끝(box.width - WALL_THICKNESS - 10, box.height - WALL_THICKNESS - 10)에서 입자 생성
                particles.push(new Particle(box.width - WALL_THICKNESS - 10, box.height - WALL_THICKNESS - 10));
            }
            particleCount += 50;
            addButton.textContent = `입자추가 (${particleCount})`;
        }

        function increaseTemperature() {
            const oldSpeedMultiplier = calculateSpeedMultiplier();
            
            temperature += 5;
            // tempButton.textContent = `온도 (${temperature}도)`; // 텍스트 업데이트 제거 (캔버스에 그림)

            const newSpeedMultiplier = calculateSpeedMultiplier();

            if (oldSpeedMultiplier > 0) {
                const scaleFactor = newSpeedMultiplier / oldSpeedMultiplier;
                
                particles.forEach(particle => {
                    particle.vx *= scaleFactor;
                    particle.vy *= scaleFactor;
                });
            }
        }

        // 온도 낮추기 함수 (새로 추가)
        function decreaseTemperature() {
            // 0도 미만으로 내려가지 않도록 방지
            if (temperature <= 0) {
                temperature = 0;
                return;
            }

            const oldSpeedMultiplier = calculateSpeedMultiplier();
            
            temperature -= 5;

            const newSpeedMultiplier = calculateSpeedMultiplier();

            if (oldSpeedMultiplier > 0) { // 0으로 나누기 방지
                const scaleFactor = newSpeedMultiplier / oldSpeedMultiplier;
                
                particles.forEach(particle => {
                    particle.vx *= scaleFactor;
                    particle.vy *= scaleFactor;
                });
            }
        }

        function resolveCollision(p1, p2, dx, dy, distance, minDistance) {
            const overlap = (minDistance - distance) / 2;
            
            const nx = dx / distance;
            const ny = dy / distance;

            p1.x -= overlap * nx;
            p1.y -= overlap * ny;
            p2.x += overlap * nx;
            p2.y += overlap * ny;

            const tx = -ny;
            const ty = nx;

            const v1_normal_dot = p1.vx * nx + p1.vy * ny;
            const v1_tangent_dot = p1.vx * tx + p1.vy * ty;
            const v2_normal_dot = p2.vx * nx + p2.vy * ny;
            const v2_tangent_dot = p2.vx * tx + p2.vy * ty;
            
            p1.vx = (v2_normal_dot * nx) + (v1_tangent_dot * tx);
            p1.vy = (v2_normal_dot * ny) + (v1_tangent_dot * ty);
            
            p2.vx = (v1_normal_dot * nx) + (v2_tangent_dot * tx);
            p2.vy = (v1_normal_dot * ny) + (v2_tangent_dot * ty);
        }

        function animate() {
            ctx.clearRect(0, 0, box.width, box.height); // 전체 캔버스 지우기

            drawStaticElements(); // 벽과 펌프/호스 그리기

            // 모든 입자 위치 업데이트 (벽 충돌 처리)
            particles.forEach(particle => {
                particle.update();
            });

            // 입자 간 충돌 처리
            for (let i = 0; i < particles.length; i++) {
                for (let j = i + 1; j < particles.length; j++) {
                    const p1 = particles[i];
                    const p2 = particles[j];

                    const dx = p2.x - p1.x;
                    const dy = p2.y - p1.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    const minDistance = p1.radius + p2.radius;

                    if (distance < minDistance) {
                        resolveCollision(p1, p2, dx, dy, distance, minDistance);
                    }
                }
            }

            // 모든 입자 그리기
            particles.forEach(particle => {
                particle.draw();
            });

            requestAnimationFrame(animate);
        }

        addButton.addEventListener('click', addParticles);
        // tempButton.addEventListener('click', increaseTemperature); // 기존 리스너 제거
        tempUpButton.addEventListener('click', increaseTemperature); // Up 버튼 리스너
        tempDownButton.addEventListener('click', decreaseTemperature); // Down 버튼 리스너

        animate();
    </script>

</body>
</html>